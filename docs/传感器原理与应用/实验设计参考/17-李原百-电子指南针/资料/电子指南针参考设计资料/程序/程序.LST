C51 COMPILER V9.52.0.0   ____                                                              12/15/2017 11:17:53 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE ____
OBJECT MODULE PLACED IN 程序.OBJ
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE 程序.c BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          
   2          
   3          
   4          #include"reg52.h"   //头文件
   5          #define uint unsigned int 
   6          #define uchar unsigned char
   7          #include <intrins.h>
   8          #include "eeprom52.h"
   9          uint tempL,tempH;
  10          unsigned char data  temp_data[2] = {0x00,0x00};
  11          
  12          sbit  DATA = P1^0; //DS18B20接入口
  13          
  14          
  15          unsigned int ReadTempDate;//读取温度
  16          uchar  tempdate[4];
  17          uchar RevFlags;
  18          
  19          #define DBPort P0   
  20          
  21          
  22          sbit rs = P2^5 ; 
  23          sbit rw = P2^6 ;
  24          sbit ep = P2^7 ;
  25          
  26          
  27          sbit K1 = P3^2; //菜单
  28          sbit K2 = P3^3;  //加
  29          sbit K3 = P3^4;  //减
  30          sbit Buzzer= P1^7;  //控制端
  31          typedef bit BOOL  ; 
  32          uchar data_byte;
  33          uchar yemian=0;
  34          uchar flag=0; //报警伐值
  35          uchar warn_tempH,warn_tempL;
  36          
  37          
  38          
  39          /*延时子函数*/
  40          void delay0(uint num)
  41          {
  42   1        while(num--) ;
  43   1      }
  44          
  45          
  46          void delay(uchar ms)
  47          {       // 延时子程序
  48   1         uchar i ;
  49   1         while(ms--)
  50   1         {
  51   2            for(i = 0 ; i<250;i++) ;
  52   2         }
  53   1      }
  54          
  55          void delay1()//延时10us
C51 COMPILER V9.52.0.0   ____                                                              12/15/2017 11:17:53 PAGE 2   

  56          {
  57   1        uchar i;
  58   1        i--;
  59   1        i--;
  60   1        i--;
  61   1        i--;
  62   1        i--;
  63   1        i--;
  64   1      }
  65          void longdelay(uchar s) //长延时
  66          {
  67   1         while(s--)
  68   1         {
  69   2            delay(10) ;
  70   2         }
  71   1      }
  72          
  73          
  74          /******************把数据保存到单片机内部eeprom中******************/
  75          void write_eeprom()
  76          {
  77   1        SectorErase(0x2000);
  78   1        byte_write(0x2000, warn_tempH);
  79   1        byte_write(0x2001, warn_tempL);
  80   1          byte_write(0x2060, a_a);  
  81   1      }
  82          
  83          /******************把数据从单片机内部eeprom中读出来*****************/
  84          void read_eeprom()
  85          {
  86   1        warn_tempH = byte_read(0x2000);
  87   1        warn_tempL = byte_read(0x2001);
  88   1          a_a      = byte_read(0x2060);
  89   1      }
  90          
  91          /**************开机自检eeprom初始化*****************/
  92          void init_eeprom()
  93          {
  94   1        read_eeprom();    //先读
  95   1        if(a_a != 3)    //新的单片机初始单片机内问eeprom
  96   1        {
  97   2          warn_tempH = 40;
  98   2            warn_tempL = 10;
  99   2          a_a = 3;
 100   2          write_eeprom();
 101   2        } 
 102   1      }
 103          
 104          
 105          
 106          
 107          //DS18b20温度传感器所需函数，分为初始化，读写字节，读取温度4个函数
 108          Init_DS18B20(void)       //传感器初始化
 109          {
 110   1        uchar x=0;
 111   1        DATA = 1;    //DQ复位
 112   1        delay0(10);  //稍做延时
 113   1        DATA = 0;    //单片机将DQ拉低
 114   1        delay0(100); //精确延时 大于 480us    //450
 115   1        DATA = 1;    //拉高总线
 116   1        delay0(20);
 117   1        x=DATA;      //稍做延时后 如果x=0则初始化成功 x=1则初始化失败
C51 COMPILER V9.52.0.0   ____                                                              12/15/2017 11:17:53 PAGE 3   

 118   1        delay0(30);
 119   1      }
 120          ReadOneChar(void)  //读一个字节
 121          {
 122   1        uchar i=0;
 123   1        uchar dat = 0;
 124   1        for (i=8;i>0;i--)
 125   1        {
 126   2            DATA = 0; // 给脉冲信号
 127   2            dat>>=1;
 128   2            DATA = 1; // 给脉冲信号
 129   2            if(DATA)
 130   2            dat|=0x80;
 131   2            delay0(8);
 132   2        }
 133   1        return(dat);
 134   1      }
 135          
 136          WriteOneChar(unsigned char dat) //写一个字节
 137          {
 138   1        uchar i=0;
 139   1        for (i=8; i>0; i--)
 140   1        {
 141   2            DATA = 0;
 142   2            DATA = dat&0x01;
 143   2          delay0(10);
 144   2          DATA = 1;
 145   2          dat>>=1;
 146   2        }
 147   1        delay0(8);
 148   1      }
 149          
 150          
 151          int ReadTemperature(void) //读取温度
 152          {
 153   1        uchar a=0;
 154   1        uchar b=0;
 155   1        int t=0;
 156   1        float tt=0;
 157   1        Init_DS18B20();
 158   1        WriteOneChar(0xCC); // 跳过读序号列号的操作
 159   1        WriteOneChar(0x44); // 启动温度转换
 160   1        Init_DS18B20();
 161   1        WriteOneChar(0xCC); //跳过读序号列号的操作
 162   1        WriteOneChar(0xBE); //读取温度寄存器等（共可读9个寄存器） 前两个就是温度
 163   1        a=ReadOneChar();//低位
 164   1        b=ReadOneChar();//高位
 165   1        temp_data[0] =a; 
 166   1        temp_data[1] =b;
 167   1        t=b;
 168   1        t<<=8;
 169   1        t=t|a;
 170   1        tt=t*0.0625;
 171   1        t= tt*10+0.5; 
 172   1        return(t);
 173   1      }
 174          
 175          
 176          
 177          
 178          
 179          /************************LCD模块******************************************/
C51 COMPILER V9.52.0.0   ____                                                              12/15/2017 11:17:53 PAGE 4   

 180          
 181          BOOL lcd_bz()//测试LCD忙碌状态
 182          {      
 183   1         BOOL result ;
 184   1         rs = 0 ;
 185   1         delay1();
 186   1         rw = 1 ;
 187   1         delay1();
 188   1         ep = 1 ;
 189   1         result = (BOOL)(P0 & 0x80) ;
 190   1         ep = 0 ;
 191   1         return result ; 
 192   1      }
 193          
 194          void write_cmd(uchar cmd)// 写指令
 195          {       
 196   1       // while(lcd_bz()) ;
 197   1        rs = 0 ;
 198   1         delay1();
 199   1        rw = 0 ;
 200   1         delay1();
 201   1        ep = 0 ;
 202   1        P0 = cmd ;
 203   1        ep = 1 ;
 204   1        ep = 0 ;  
 205   1      }
 206          
 207          void write_addr(uchar addr)//写地址
 208          {       
 209   1        write_cmd(addr|0x80) ;
 210   1      }
 211          
 212          void write_byte(uchar dat)//写字节
 213          {      
 214   1        //while(lcd_bz()) ;
 215   1         delay1();
 216   1          rs = 1 ;
 217   1         delay1();
 218   1          rw = 0 ;
 219   1         delay1();
 220   1          ep = 0 ;
 221   1         delay1();
 222   1          P0 = dat ;
 223   1          ep = 1 ;
 224   1         delay1();
 225   1          ep = 0 ; 
 226   1      }
 227          
 228          void lcd_init()// 初始化
 229          {       
 230   1         write_cmd(0x38) ; 
 231   1         delay(1);
 232   1         write_cmd(0x08) ;  
 233   1         delay(1);
 234   1         write_cmd(0x01) ; 
 235   1         delay(1);
 236   1         write_cmd(0x06) ;
 237   1         delay(1);
 238   1         write_cmd(0x0c) ; 
 239   1         delay(1);
 240   1      }
 241          
C51 COMPILER V9.52.0.0   ____                                                              12/15/2017 11:17:53 PAGE 5   

 242           display(uchar addr, uchar q)//在某一地址上显示一字节
 243          {    
 244   1         delay(1) ;
 245   1         write_addr(addr) ;
 246   1         write_byte(q) ;
 247   1         //longdelay(1) ;
 248   1         
 249   1      }
 250          
 251          
 252          
 253          
 254          
 255          void show1()
 256          {     
 257   1           lcd_init();// 初始化   
 258   1        //  Welcome
 259   1               display(0x05,'W');
 260   1               display(0x06,'e');
 261   1           display(0x07,'l');
 262   1           display(0x08,'c');
 263   1           display(0x09,'o');
 264   1           display(0x0a,'m');
 265   1               display(0x0b,'e');
 266   1             delay(250) ;
 267   1             delay(250) ;
 268   1          
 269   1        /**************
 270   1           display(0x42,'G');
 271   1               display(0x43,'u'); 
 272   1           display(0x44,'a');
 273   1           display(0x45,'n');
 274   1           display(0x46,'g');
 275   1           display(0x48,'M');
 276   1             display(0x49,'i');
 277   1             display(0x4a,'n');
 278   1           display(0x4b,'g');
 279   1         
 280   1        *************************/
 281   1         
 282   1         
 283   1           
 284   1        
 285   1      }
 286          
 287          
 288          
 289          /*************************串口初始化函数**************/
 290          void Max232Int()
 291          {
 292   1        PCON=0x00;   //SMOD=0
 293   1        TMOD=0x20;  //设置T1为工作方式2
 294   1        TH1=0xfd;  //9600
 295   1        TL1=0xfd;
 296   1        SM0=0;
 297   1        SM1=1;//方式1,8位
 298   1        EA=1;
 299   1        ES=1;
 300   1        TR1=1;//定时器1允许
 301   1        REN=1;//允许接收
 302   1      }
 303          /*************************串口发送一个字节函数********************/
C51 COMPILER V9.52.0.0   ____                                                              12/15/2017 11:17:53 PAGE 6   

 304          void Max232SendChar(uchar date)
 305          {
 306   1         ES=0;
 307   1         SBUF=date;
 308   1         while(!TI);
 309   1           TI=0;
 310   1           ES=1;
 311   1      }
 312          /**********************发送一个字符串******************************/
 313          void Max232SendAChar(uchar *string)
 314          {
 315   1        while(*string!='\0')
 316   1         {
 317   2            Max232SendChar(*string);
 318   2          string++;
 319   2         }
 320   1      }
 321          /**********************串口中断接收函数****************************/
 322          void ExInt() interrupt 4 
 323          {
 324   1        ES=0;
 325   1        if(RI)
 326   1          {
 327   2          RI=0;
 328   2          RevFlags=SBUF;
 329   2        }
 330   1        ES=1;
 331   1      } 
 332          /*********************发送NRF24L01采集到的数据********************/
 333          void MAX232SendDate()
 334          {
 335   1        if(RevFlags=='s')
 336   1        {
 337   2           RevFlags=0;
 338   2           Max232SendChar(temp_data[0]);
 339   2           Max232SendChar(temp_data[1]);
 340   2          
 341   2        }
 342   1        //Max232SendChar('E');//发送结束标志
 343   1      }
 344          
 345          
 346          void key() //按键程序 选择菜单模式
 347          {
 348   1           
 349   1          if(!K1)
 350   1             {  
 351   2               delay(20);
 352   2                if(!K1)
 353   2                   {   
 354   3                 while(!K1)
 355   3                         ;
 356   3                    yemian++;
 357   3                    if(yemian>=3) { yemian=0; } 
 358   3                      
 359   3                   }
 360   2             }
 361   1       
 362   1        
 363   1        
 364   1      }
 365          
C51 COMPILER V9.52.0.0   ____                                                              12/15/2017 11:17:53 PAGE 7   

 366          
 367          void  baojin() //温度检测
 368          {
 369   1      
 370   1           if( ReadTempDate>=warn_tempH*10  || ReadTempDate<warn_tempL*10 )  
 371   1            {
 372   2                    Buzzer=0;
 373   2            } 
 374   1      
 375   1           if( ReadTempDate<warn_tempH*10   && ReadTempDate>=warn_tempL*10 )
 376   1            {  
 377   2              Buzzer=1;//停止报警
 378   2                  }
 379   1      }
 380          
 381          
 382          
 383          void shezhi()  //对里面的数值进行修改
 384          {
 385   1         if(!K2)            //按下按键
 386   1            {
 387   2            delay(30);       //延时去抖
 388   2          if(!K2)
 389   2            { 
 390   3                  if(yemian==1) 
 391   3                    {               
 392   4              warn_tempH+=1;       //没按下一次，数值加1
 393   4              if(warn_tempH>=100)  {warn_tempH=99;}
 394   4                      write_eeprom();       //保存数据
 395   4                display(0x46,warn_tempH/10+'0');
 396   4              display(0x47,warn_tempH%10+'0');
 397   4                    }
 398   3                    
 399   3            if(yemian==2) 
 400   3                    {               
 401   4                    //没按下一次，数值加1
 402   4                 if(warn_tempL<warn_tempH+1)  {warn_tempL+=1; }
 403   4                 write_eeprom();       //保存数据
 404   4                 display(0x46,warn_tempL/10+'0');
 405   4                 display(0x47,warn_tempL%10+'0');
 406   4              } 
 407   3                 }
 408   2                // while(!K2);      //等待按键 弹起  屏蔽此句，可以实现按键按下不放开时，连加技术功能，
 409   2                                  //   不过需要将上面延时去抖时间延长效果才好。建议改为： delay_LCD(50);  
 410   2            }
 411   1             
 412   1             
 413   1         if(!K3)            //按下按键
 414   1           {
 415   2            delay(30);       //延时去抖
 416   2          if(!K3)
 417   2            { 
 418   3                 if(yemian==1) 
 419   3                   {                
 420   4              
 421   4              if(warn_tempH>warn_tempL+1)  {warn_tempH--;}
 422   4                      write_eeprom();       //保存数据
 423   4                display(0x46,warn_tempH/10+'0');
 424   4              display(0x47,warn_tempH%10+'0');
 425   4             }
 426   3                    
 427   3            if(yemian==2) 
C51 COMPILER V9.52.0.0   ____                                                              12/15/2017 11:17:53 PAGE 8   

 428   3                    {               
 429   4              warn_tempL-=1;       //没按下一次，数值加1
 430   4               if(warn_tempL<=1)  {warn_tempL=1;}
 431   4                      write_eeprom();       //保存数据
 432   4                display(0x46,warn_tempL/10+'0');
 433   4              display(0x47,warn_tempL%10+'0');
 434   4             }  
 435   3                 }
 436   2              //   while(!K3);      //等待按键 弹起  //等待按键 弹起  屏蔽此句，可以实现按键按下不放开时，连加技术功
             -能，
 437   2                                  //   不过需要将上面延时去抖时间延长效果才好。建议改为： delay_LCD(50);  
 438   2             }
 439   1      
 440   1          
 441   1      } 
 442          
 443          
 444          /************************主函数********************/
 445          void main()
 446          {  
 447   1           ReadTempDate=ReadTemperature();
 448   1         show1();//显示问候语和其他信息
 449   1           Max232Int();//串口初始化
 450   1         init_eeprom();           //读eeprom数据
 451   1       while(1)
 452   1          {
 453   2      
 454   2           key(); //按键扫描
 455   2      
 456   2            //==================//进入工作状态=====================   
 457   2          if(yemian==0)  
 458   2            {
 459   3              if(flag==0)
 460   3               {
 461   4                        flag=1;
 462   4                       lcd_init();// 初始化
 463   4        
 464   4                       display(0x02,'T');
 465   4                       display(0x03,'e');
 466   4                       display(0x04,'m');
 467   4                       display(0x05,'p');
 468   4                       display(0x06,':');
 469   4      
 470   4                       display(0x0b,0xdf);
 471   4                       display(0x0c,'C');
 472   4      
 473   4               display(0x40,'T');
 474   4                       display(0x41,'H');
 475   4                       display(0x42,':');
 476   4               display(0x43,warn_tempH/10+'0');
 477   4               display(0x44,warn_tempH%10+'0');
 478   4      
 479   4      
 480   4      
 481   4               display(0x4a,'T');
 482   4                       display(0x4b,'L');
 483   4                       display(0x4c,':');
 484   4               display(0x4d,warn_tempL/10+'0');
 485   4               display(0x4e,warn_tempL%10+'0');
 486   4      
 487   4                      }
 488   3            
C51 COMPILER V9.52.0.0   ____                                                              12/15/2017 11:17:53 PAGE 9   

 489   3                      ReadTempDate=ReadTemperature();
 490   3           tempdate[0]=ReadTempDate/100+'0';
 491   3           tempdate[1]=ReadTempDate%100/10+'0';
 492   3           tempdate[2]='.';
 493   3           tempdate[3]=ReadTempDate%100%10+'0';
 494   3           
 495   3           display(0x07,tempdate[0]);
 496   3           display(0x08,tempdate[1]);
 497   3           display(0x09,tempdate[2]);
 498   3               display(0x0a,tempdate[3]);
 499   3           MAX232SendDate();//发送到上位机
 500   3           baojin() ;//报警   
 501   3           }
 502   2          
 503   2        //==================//进入温度上限设置状态=====================      
 504   2          if(yemian==1)  //进入设置模式
 505   2           { 
 506   3              
 507   3               if(flag==1)
 508   3               {
 509   4                             flag=2;
 510   4                             Buzzer=1;
 511   4                   lcd_init();// 初始化 
 512   4                   display(0x04,'T');
 513   4                             display(0x05,'e');
 514   4                             display(0x06,'m');
 515   4                   display(0x07,'p');
 516   4                   display(0x08,'_');
 517   4                   display(0x09,'H');
 518   4      
 519   4                   display(0x46,warn_tempH/10+'0');
 520   4                     display(0x47,warn_tempH%10+'0');
 521   4                      }
 522   3               
 523   3               shezhi();
 524   3               
 525   3            
 526   3            }
 527   2            
 528   2      //==================//进入湿度设置状态=====================      
 529   2          if(yemian==2)  //进入设置模式
 530   2           { 
 531   3              
 532   3               if(flag==2)
 533   3               {
 534   4                             flag=0;
 535   4                   Buzzer=1;
 536   4                             lcd_init();// 初始化 
 537   4                   display(0x04,'T');
 538   4                             display(0x05,'e');
 539   4                             display(0x06,'m');
 540   4                   display(0x07,'p');
 541   4                   display(0x08,'_');
 542   4                   display(0x09,'L');
 543   4      
 544   4                   display(0x46,warn_tempL/10+'0');
 545   4                     display(0x47,warn_tempL%10+'0');
 546   4                     }
 547   3               
 548   3               shezhi();
 549   3               
 550   3              
C51 COMPILER V9.52.0.0   ____                                                              12/15/2017 11:17:53 PAGE 10  

 551   3            }
 552   2      
 553   2             
 554   2         }
 555   1      }
*** WARNING C290 IN LINE 119 OF 程序.c: missing return value
*** WARNING C290 IN LINE 148 OF 程序.c: missing return value
*** WARNING C290 IN LINE 249 OF 程序.c: missing return value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1520    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     19       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
